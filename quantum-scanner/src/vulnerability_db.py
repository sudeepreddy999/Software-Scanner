"""
Vulnerability Database
Contains signatures and patterns for quantum-vulnerable cryptographic algorithms
"""

from enum import Enum
from typing import List, Dict, Any


class Severity(Enum):
    """Severity levels for vulnerabilities"""
    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"
    SAFE = "SAFE"  # For quantum-safe/post-quantum algorithms


class VulnerabilitySignature:
    """Represents a quantum-vulnerable cryptographic signature"""
    
    def __init__(
        self,
        algorithm: str,
        severity: Severity,
        description: str,
        recommendation: str,
        patterns: List[str],
        language: str = "all",
        references: List[str] = None
    ):
        self.algorithm = algorithm
        self.severity = severity
        self.description = description
        self.recommendation = recommendation
        self.patterns = patterns
        self.language = language
        self.references = references or []
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary representation"""
        return {
            "algorithm": self.algorithm,
            "severity": self.severity.value,
            "description": self.description,
            "recommendation": self.recommendation,
            "patterns": self.patterns,
            "language": self.language
        }


class VulnerabilityDatabase:
    """Database of quantum-vulnerable cryptographic algorithms"""
    
    def __init__(self):
        self.signatures: List[VulnerabilitySignature] = []
        self._initialize_database()
    
    def _initialize_database(self):
        """Initialize the vulnerability database with known patterns"""
        
        # RSA vulnerabilities
        self.signatures.extend([
            VulnerabilitySignature(
                algorithm="RSA",
                severity=Severity.CRITICAL,
                description="RSA encryption/signatures are vulnerable to Shor's algorithm on quantum computers. All key sizes are affected.",
                recommendation="Replace with CRYSTALS-Kyber for key encapsulation or CRYSTALS-Dilithium for digital signatures.",
                patterns=[
                    r"RSA\.generate",  # Python
                    r"RSA_generate_key",  # OpenSSL C/C++
                    r"KeyPairGenerator\.getInstance\([\"']RSA[\"']\)",  # Java
                    r"from\s+Crypto\.PublicKey\s+import\s+RSA",  # Python
                    r"from\s+cryptography\.hazmat\.primitives\.asymmetric\s+import\s+rsa",  # Python
                    r"new\s+RSACryptoServiceProvider",  # C# .NET (for reference)
                    r"RSA\.Create\(\)",  # C# .NET modern (for reference)
                ],
                language="all"
            ),
            VulnerabilitySignature(
                algorithm="RSA-PKCS1",
                severity=Severity.CRITICAL,
                description="RSA with PKCS#1 padding is quantum-vulnerable.",
                recommendation="Migrate to CRYSTALS-Kyber or CRYSTALS-Dilithium.",
                patterns=[
                    r"PKCS1_OAEP",
                    r"PKCS1v15",
                    r"RSA/ECB/PKCS1Padding",
                    r"padding\.PKCS1",
                ],
                language="all"
            ),
        ])
        
        # ECDSA/ECC vulnerabilities
        self.signatures.extend([
            VulnerabilitySignature(
                algorithm="ECDSA",
                severity=Severity.CRITICAL,
                description="Elliptic Curve Digital Signature Algorithm is vulnerable to quantum attacks using modified Shor's algorithm.",
                recommendation="Replace with CRYSTALS-Dilithium, SPHINCS+, or FALCON for post-quantum signatures.",
                patterns=[
                    r"ECDSA",
                    r"ec\.generate_private_key",  # Python
                    r"EC\.generate",  # Python
                    r"KeyPairGenerator\.getInstance\([\"']EC[\"']\)",  # Java
                    r"Signature\.getInstance\([\"'].*ECDSA[\"']\)",  # Java
                    r"from\s+ecdsa\s+import",  # Python
                ],
                language="all"
            ),
            VulnerabilitySignature(
                algorithm="ECDH",
                severity=Severity.CRITICAL,
                description="Elliptic Curve Diffie-Hellman key exchange is quantum-vulnerable.",
                recommendation="Replace with CRYSTALS-Kyber for quantum-safe key encapsulation.",
                patterns=[
                    r"ECDH",
                    r"ec\.derive_key",  # Python
                    r"KeyAgreement\.getInstance\([\"']ECDH[\"']\)",  # Java
                ],
                language="all"
            ),
            VulnerabilitySignature(
                algorithm="ECC",
                severity=Severity.CRITICAL,
                description="Elliptic Curve Cryptography is vulnerable to quantum computers.",
                recommendation="Migrate to lattice-based or hash-based post-quantum cryptography.",
                patterns=[
                    r"EllipticCurve",
                    r"ECGenParameterSpec",  # Java
                    r"SECP256[Rr]1",
                    r"SECP384[Rr]1",
                    r"SECP521[Rr]1",
                    r"prime256v1",
                    r"secp256k1",
                    r"P-256",
                    r"P-384",
                    r"P-521",
                ],
                language="all"
            ),
        ])
        
        # DSA vulnerabilities
        self.signatures.append(
            VulnerabilitySignature(
                algorithm="DSA",
                severity=Severity.CRITICAL,
                description="Digital Signature Algorithm is vulnerable to quantum attacks.",
                recommendation="Replace with CRYSTALS-Dilithium or SPHINCS+ for quantum-resistant signatures.",
                patterns=[
                    r"DSA\.generate",  # Python
                    r"KeyPairGenerator\.getInstance\([\"']DSA[\"']\)",  # Java
                    r"Signature\.getInstance\([\"'].*DSA[\"']\)",  # Java
                    r"from\s+Crypto\.PublicKey\s+import\s+DSA",  # Python
                    r"DSAParameters",  # Java
                ],
                language="all"
            )
        )
        
        # Diffie-Hellman vulnerabilities
        self.signatures.extend([
            VulnerabilitySignature(
                algorithm="Diffie-Hellman",
                severity=Severity.HIGH,
                description="Diffie-Hellman key exchange is vulnerable to Shor's algorithm.",
                recommendation="Use CRYSTALS-Kyber for quantum-safe key encapsulation mechanism (KEM).",
                patterns=[
                    r"DiffieHellman",
                    r"DHParameterSpec",  # Java
                    r"KeyAgreement\.getInstance\([\"']DH[\"']\)",  # Java
                    r"DH\.generate",
                ],
                language="all"
            ),
        ])
        
        # ElGamal
        self.signatures.append(
            VulnerabilitySignature(
                algorithm="ElGamal",
                severity=Severity.HIGH,
                description="ElGamal encryption is based on discrete logarithm problem, vulnerable to quantum attacks.",
                recommendation="Replace with CRYSTALS-Kyber or other lattice-based encryption.",
                patterns=[
                    r"ElGamal",
                    r"from\s+Crypto\.PublicKey\s+import\s+ElGamal",  # Python
                ],
                language="all"
            )
        )
        
        # Python-specific patterns
        self.signatures.extend([
            VulnerabilitySignature(
                algorithm="PyCrypto/PyCryptodome RSA",
                severity=Severity.CRITICAL,
                description="PyCrypto/PyCryptodome RSA implementation is quantum-vulnerable.",
                recommendation="Migrate to post-quantum algorithms using liboqs-python.",
                patterns=[
                    r"from\s+Crypto\.Cipher\s+import\s+PKCS1_OAEP",
                    r"from\s+Crypto\.Signature\s+import\s+pkcs1_15",
                    r"from\s+Crypto\.Signature\s+import\s+pss",
                ],
                language="python"
            ),
            VulnerabilitySignature(
                algorithm="cryptography library asymmetric",
                severity=Severity.CRITICAL,
                description="Python cryptography library's asymmetric algorithms are quantum-vulnerable.",
                recommendation="Consider using liboqs-python for post-quantum cryptography.",
                patterns=[
                    r"from\s+cryptography\.hazmat\.primitives\.asymmetric\s+import",
                    r"serialization\.load_pem_private_key",
                    r"serialization\.load_ssh_private_key",
                ],
                language="python"
            ),
        ])
        
        # Java-specific patterns
        self.signatures.extend([
            VulnerabilitySignature(
                algorithm="Java JCE RSA/ECC",
                severity=Severity.CRITICAL,
                description="Java Cryptography Extension's RSA and ECC implementations are quantum-vulnerable.",
                recommendation="Use Bouncy Castle's post-quantum cryptography providers.",
                patterns=[
                    r"javax\.crypto\.Cipher",
                    r"java\.security\.KeyPairGenerator",
                    r"java\.security\.Signature",
                    r"KeyFactory\.getInstance",
                ],
                language="java"
            ),
        ])
        
        # C/C++ OpenSSL patterns
        self.signatures.extend([
            VulnerabilitySignature(
                algorithm="OpenSSL RSA/ECC",
                severity=Severity.CRITICAL,
                description="OpenSSL's RSA and ECC implementations are quantum-vulnerable.",
                recommendation="Use liboqs (Open Quantum Safe) for post-quantum cryptography in C/C++.",
                patterns=[
                    r"RSA_new\(",
                    r"RSA_generate_key",
                    r"EC_KEY_new",
                    r"EC_KEY_generate_key",
                    r"EVP_PKEY_CTX_new",
                    r"EVP_PKEY_keygen",
                    r"#include\s+<openssl/rsa\.h>",
                    r"#include\s+<openssl/ec\.h>",
                ],
                language="c_cpp"
            ),
        ])
        
        # Post-Quantum Cryptography (PQC) - SAFE Algorithms
        self.signatures.extend([
            VulnerabilitySignature(
                algorithm="CRYSTALS-Kyber",
                severity=Severity.SAFE,
                description="CRYSTALS-Kyber is a NIST-standardized post-quantum key encapsulation mechanism (KEM) based on Module Learning With Errors (MLWE).",
                recommendation="This algorithm is quantum-safe. Continue using for secure key exchange.",
                patterns=[
                    r"kyber",
                    r"KYBER",
                    r"ML-KEM",
                    r"from\s+pqcrypto\.kem\.kyber",  # Python
                    r"from\s+liboqs\s+import.*Kyber",  # Python
                    r"OQS_KEM_kyber",  # C/C++
                    r"kyber\d+",
                    r"Kyber\.generate",
                    r"KyberKEM",
                ],
                language="all",
                references=[
                    "https://pq-crystals.org/kyber/",
                    "https://csrc.nist.gov/projects/post-quantum-cryptography"
                ]
            ),
            VulnerabilitySignature(
                algorithm="CRYSTALS-Dilithium",
                severity=Severity.SAFE,
                description="CRYSTALS-Dilithium is a NIST-standardized post-quantum digital signature scheme based on Module Learning With Errors (MLWE).",
                recommendation="This algorithm is quantum-safe. Continue using for secure digital signatures.",
                patterns=[
                    r"dilithium",
                    r"DILITHIUM",
                    r"ML-DSA",
                    r"from\s+pqcrypto\.sign\.dilithium",  # Python
                    r"from\s+liboqs\s+import.*Dilithium",  # Python
                    r"OQS_SIG_dilithium",  # C/C++
                    r"dilithium\d+",
                    r"Dilithium\.sign",
                    r"DilithiumSignature",
                ],
                language="all",
                references=[
                    "https://pq-crystals.org/dilithium/",
                    "https://csrc.nist.gov/projects/post-quantum-cryptography"
                ]
            ),
            VulnerabilitySignature(
                algorithm="SPHINCS+",
                severity=Severity.SAFE,
                description="SPHINCS+ is a NIST-standardized post-quantum signature scheme based on hash functions, providing stateless hash-based signatures.",
                recommendation="This algorithm is quantum-safe. Continue using for secure digital signatures.",
                patterns=[
                    r"sphincs",
                    r"SPHINCS\+",
                    r"SLH-DSA",
                    r"from\s+pqcrypto\.sign\.sphincs",  # Python
                    r"from\s+liboqs\s+import.*SPHINCS",  # Python
                    r"OQS_SIG_sphincs",  # C/C++
                    r"sphincsplus",
                    r"SphincsSignature",
                ],
                language="all",
                references=[
                    "https://sphincs.org/",
                    "https://csrc.nist.gov/projects/post-quantum-cryptography"
                ]
            ),
            VulnerabilitySignature(
                algorithm="FALCON",
                severity=Severity.SAFE,
                description="FALCON is a NIST-standardized post-quantum signature scheme based on NTRU lattices, offering compact signatures.",
                recommendation="This algorithm is quantum-safe. Continue using for secure digital signatures with smaller signature sizes.",
                patterns=[
                    r"falcon",
                    r"FALCON",
                    r"from\s+pqcrypto\.sign\.falcon",  # Python
                    r"from\s+liboqs\s+import.*Falcon",  # Python
                    r"OQS_SIG_falcon",  # C/C++
                    r"falcon\d+",
                    r"FalconSignature",
                ],
                language="all",
                references=[
                    "https://falcon-sign.info/",
                    "https://csrc.nist.gov/projects/post-quantum-cryptography"
                ]
            ),
            VulnerabilitySignature(
                algorithm="NTRU",
                severity=Severity.SAFE,
                description="NTRU is a lattice-based post-quantum encryption algorithm with efficient key generation and encryption operations.",
                recommendation="This algorithm is quantum-safe. Continue using for secure key encapsulation.",
                patterns=[
                    r"ntru",
                    r"NTRU",
                    r"from\s+pqcrypto\.kem\.ntru",  # Python
                    r"NTRUEncrypt",
                    r"ntruencrypt",
                ],
                language="all",
                references=[
                    "https://ntru.org/",
                    "https://en.wikipedia.org/wiki/NTRU"
                ]
            ),
            VulnerabilitySignature(
                algorithm="Classic McEliece",
                severity=Severity.SAFE,
                description="Classic McEliece is a code-based post-quantum key encapsulation mechanism with strong security guarantees.",
                recommendation="This algorithm is quantum-safe. Continue using for secure key exchange, though note larger key sizes.",
                patterns=[
                    r"mceliece",
                    r"McEliece",
                    r"MCELIECE",
                    r"from\s+pqcrypto\.kem\.mceliece",  # Python
                    r"classic_mceliece",
                ],
                language="all",
                references=[
                    "https://classic.mceliece.org/",
                    "https://csrc.nist.gov/projects/post-quantum-cryptography"
                ]
            ),
            VulnerabilitySignature(
                algorithm="FrodoKEM",
                severity=Severity.SAFE,
                description="FrodoKEM is a conservative post-quantum key encapsulation mechanism based on Learning With Errors (LWE) over generic lattices.",
                recommendation="This algorithm is quantum-safe. Continue using for secure key exchange with conservative security assumptions.",
                patterns=[
                    r"frodo",
                    r"FrodoKEM",
                    r"FRODO",
                    r"from\s+pqcrypto\.kem\.frodo",  # Python
                    r"frodokem",
                ],
                language="all",
                references=[
                    "https://frodokem.org/",
                    "https://csrc.nist.gov/projects/post-quantum-cryptography"
                ]
            ),
        ])
    
    def get_signatures_by_language(self, language: str) -> List[VulnerabilitySignature]:
        """Get all signatures for a specific language"""
        return [
            sig for sig in self.signatures
            if sig.language == language or sig.language == "all"
        ]
    
    def get_all_signatures(self) -> List[VulnerabilitySignature]:
        """Get all vulnerability signatures"""
        return self.signatures
    
    def get_signature_by_algorithm(self, algorithm: str) -> VulnerabilitySignature:
        """Get signature by algorithm name"""
        for sig in self.signatures:
            if sig.algorithm.lower() == algorithm.lower():
                return sig
        return None
    
    def get_severity_for_algorithm_and_size(self, algorithm: str, key_size: int = None) -> Severity:
        # Normalize algorithm name for comparison
        alg_lower = algorithm.lower()
        
        # Post-quantum algorithms are always SAFE
        if any(pqc in alg_lower for pqc in ['kyber', 'dilithium', 'sphincs', 'falcon', 'ntru', 'mceliece', 'frodo']):
            return Severity.SAFE
        
        # If no key size, return default from signature
        if key_size is None:
            sig = self.get_signature_by_algorithm(algorithm)
            return sig.severity if sig else Severity.HIGH
        
        # RSA severity by key size
        if 'rsa' in alg_lower:
            if key_size < 2048:
                return Severity.CRITICAL
            elif key_size == 2048:
                return Severity.HIGH
            elif key_size <= 4096:
                return Severity.MEDIUM
            else:
                return Severity.LOW
        
        # ECDSA/ECDH/ECC severity by key size (curve strength)
        if any(ecc in alg_lower for ecc in ['ecdsa', 'ecdh', 'ecc', 'ec']):
            if key_size < 256:
                return Severity.CRITICAL
            elif key_size == 256:
                return Severity.HIGH
            else:  # 384, 521, etc.
                return Severity.MEDIUM
        
        # DSA severity by key size
        if 'dsa' in alg_lower and 'ecdsa' not in alg_lower:
            if key_size < 2048:
                return Severity.CRITICAL
            else:
                return Severity.HIGH
        
        # DH/Diffie-Hellman severity
        if 'diffie' in alg_lower or alg_lower == 'dh':
            if key_size < 2048:
                return Severity.CRITICAL
            else:
                return Severity.HIGH
        
        # Default: use signature severity or HIGH
        sig = self.get_signature_by_algorithm(algorithm)
        return sig.severity if sig else Severity.HIGH
